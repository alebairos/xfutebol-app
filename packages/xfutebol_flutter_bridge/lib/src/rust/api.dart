// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Create a new game with the specified mode
Future<String> newGame({required GameModeType mode}) =>
    XfutebolBridge.instance.api.crateApiNewGame(mode: mode);

/// Get the current board state for display
Future<BoardView> getBoard({required String gameId}) =>
    XfutebolBridge.instance.api.crateApiGetBoard(gameId: gameId);

/// Get legal moves for a specific piece
Future<List<Position>> getLegalMoves({
  required String gameId,
  required int pieceId,
}) => XfutebolBridge.instance.api.crateApiGetLegalMoves(
  gameId: gameId,
  pieceId: pieceId,
);

/// Execute a move action
Future<ActionResult> executeMove({
  required String gameId,
  required int pieceId,
  required Position to,
}) => XfutebolBridge.instance.api.crateApiExecuteMove(
  gameId: gameId,
  pieceId: pieceId,
  to: to,
);

/// Get the bot's move for the current position
Future<(int, Position)?> getBotMove({
  required String gameId,
  required Difficulty difficulty,
}) => XfutebolBridge.instance.api.crateApiGetBotMove(
  gameId: gameId,
  difficulty: difficulty,
);

/// Check if the game is over
Future<bool> isGameOver({required String gameId}) =>
    XfutebolBridge.instance.api.crateApiIsGameOver(gameId: gameId);

/// Get the winner (if game is over)
Future<Team?> getWinner({required String gameId}) =>
    XfutebolBridge.instance.api.crateApiGetWinner(gameId: gameId);

/// Simple test function to verify bridge works
Future<String> greet({required String name}) =>
    XfutebolBridge.instance.api.crateApiGreet(name: name);

/// Result of an action
class ActionResult {
  final bool success;
  final String message;
  final bool gameOver;
  final Team? winner;

  const ActionResult({
    required this.success,
    required this.message,
    required this.gameOver,
    this.winner,
  });

  @override
  int get hashCode =>
      success.hashCode ^ message.hashCode ^ gameOver.hashCode ^ winner.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ActionResult &&
          runtimeType == other.runtimeType &&
          success == other.success &&
          message == other.message &&
          gameOver == other.gameOver &&
          winner == other.winner;
}

/// Current state of the board for display
class BoardView {
  final List<PieceView> pieces;
  final Position? ballPosition;
  final Team currentTurn;
  final int actionsRemaining;
  final int whiteScore;
  final int blackScore;
  final int turnNumber;

  const BoardView({
    required this.pieces,
    this.ballPosition,
    required this.currentTurn,
    required this.actionsRemaining,
    required this.whiteScore,
    required this.blackScore,
    required this.turnNumber,
  });

  @override
  int get hashCode =>
      pieces.hashCode ^
      ballPosition.hashCode ^
      currentTurn.hashCode ^
      actionsRemaining.hashCode ^
      whiteScore.hashCode ^
      blackScore.hashCode ^
      turnNumber.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BoardView &&
          runtimeType == other.runtimeType &&
          pieces == other.pieces &&
          ballPosition == other.ballPosition &&
          currentTurn == other.currentTurn &&
          actionsRemaining == other.actionsRemaining &&
          whiteScore == other.whiteScore &&
          blackScore == other.blackScore &&
          turnNumber == other.turnNumber;
}

/// Game difficulty levels
enum Difficulty { easy, medium, hard }

/// Game mode options
enum GameModeType { quickMatch, standardMatch, goldenGoal }

/// Piece roles
enum PieceRole { goalkeeper, defender, midfielder, attacker }

/// A piece on the board
class PieceView {
  final int id;
  final Team team;
  final PieceRole role;
  final Position position;
  final bool hasBall;

  const PieceView({
    required this.id,
    required this.team,
    required this.role,
    required this.position,
    required this.hasBall,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      team.hashCode ^
      role.hashCode ^
      position.hashCode ^
      hasBall.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PieceView &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          team == other.team &&
          role == other.role &&
          position == other.position &&
          hasBall == other.hasBall;
}

/// A position on the board (0-7 for row and col)
class Position {
  final int row;
  final int col;

  const Position({required this.row, required this.col});

  @override
  int get hashCode => row.hashCode ^ col.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Position &&
          runtimeType == other.runtimeType &&
          row == other.row &&
          col == other.col;
}

/// Team colors
enum Team { white, black }
