// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `error`, `execute_path_action`, `from_outcome`, `get_legal_action_paths`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`

/// Create a new game with the specified mode
Future<String> newGame({required GameModeType mode}) =>
    XfutebolBridge.instance.api.crateApiNewGame(mode: mode);

/// Get the current board state for display
Future<BoardView?> getBoard({required String gameId}) =>
    XfutebolBridge.instance.api.crateApiGetBoard(gameId: gameId);

/// Get legal moves for a specific piece
Future<List<Position>> getLegalMoves({
  required String gameId,
  required String pieceId,
}) => XfutebolBridge.instance.api.crateApiGetLegalMoves(
  gameId: gameId,
  pieceId: pieceId,
);

/// Get legal pass paths for a piece (must have ball)
Future<List<PositionPath>> getLegalPasses({
  required String gameId,
  required String pieceId,
}) => XfutebolBridge.instance.api.crateApiGetLegalPasses(
  gameId: gameId,
  pieceId: pieceId,
);

/// Get legal shoot paths for a piece (must have ball)
Future<List<PositionPath>> getLegalShoots({
  required String gameId,
  required String pieceId,
}) => XfutebolBridge.instance.api.crateApiGetLegalShoots(
  gameId: gameId,
  pieceId: pieceId,
);

/// Get legal intercept paths for a piece
Future<List<PositionPath>> getLegalIntercepts({
  required String gameId,
  required String pieceId,
}) => XfutebolBridge.instance.api.crateApiGetLegalIntercepts(
  gameId: gameId,
  pieceId: pieceId,
);

/// Get legal kick paths for a piece (must have ball)
Future<List<PositionPath>> getLegalKicks({
  required String gameId,
  required String pieceId,
}) => XfutebolBridge.instance.api.crateApiGetLegalKicks(
  gameId: gameId,
  pieceId: pieceId,
);

/// Get legal defend paths for a piece
Future<List<PositionPath>> getLegalDefends({
  required String gameId,
  required String pieceId,
}) => XfutebolBridge.instance.api.crateApiGetLegalDefends(
  gameId: gameId,
  pieceId: pieceId,
);

/// Get legal push targets for a piece (adjacent opponents that can be pushed)
Future<List<PositionPath>> getLegalPushes({
  required String gameId,
  required String pieceId,
}) => XfutebolBridge.instance.api.crateApiGetLegalPushes(
  gameId: gameId,
  pieceId: pieceId,
);

/// Execute a move action
Future<ActionResult> executeMove({
  required String gameId,
  required String pieceId,
  required Position to,
}) => XfutebolBridge.instance.api.crateApiExecuteMove(
  gameId: gameId,
  pieceId: pieceId,
  to: to,
);

/// Execute a pass action
Future<ActionResult> executePass({
  required String gameId,
  required String pieceId,
  required List<Position> path,
}) => XfutebolBridge.instance.api.crateApiExecutePass(
  gameId: gameId,
  pieceId: pieceId,
  path: path,
);

/// Execute a shoot action
Future<ActionResult> executeShoot({
  required String gameId,
  required String pieceId,
  required List<Position> path,
}) => XfutebolBridge.instance.api.crateApiExecuteShoot(
  gameId: gameId,
  pieceId: pieceId,
  path: path,
);

/// Execute an intercept action
Future<ActionResult> executeIntercept({
  required String gameId,
  required String pieceId,
  required List<Position> path,
}) => XfutebolBridge.instance.api.crateApiExecuteIntercept(
  gameId: gameId,
  pieceId: pieceId,
  path: path,
);

/// Execute a kick action (clear the ball)
Future<ActionResult> executeKick({
  required String gameId,
  required String pieceId,
  required List<Position> path,
}) => XfutebolBridge.instance.api.crateApiExecuteKick(
  gameId: gameId,
  pieceId: pieceId,
  path: path,
);

/// Execute a defend action (defensive positioning)
Future<ActionResult> executeDefend({
  required String gameId,
  required String pieceId,
  required List<Position> path,
}) => XfutebolBridge.instance.api.crateApiExecuteDefend(
  gameId: gameId,
  pieceId: pieceId,
  path: path,
);

/// Execute a push action (push adjacent opponent)
Future<ActionResult> executePush({
  required String gameId,
  required String pieceId,
  required Position target,
  required Position destination,
}) => XfutebolBridge.instance.api.crateApiExecutePush(
  gameId: gameId,
  pieceId: pieceId,
  target: target,
  destination: destination,
);

/// Get the bot's move for the current position (deprecated: use get_bot_action)
Future<(String, Position)?> getBotMove({
  required String gameId,
  required Difficulty difficulty,
}) => XfutebolBridge.instance.api.crateApiGetBotMove(
  gameId: gameId,
  difficulty: difficulty,
);

/// Get the bot's recommended action with full details
Future<BotAction?> getBotAction({
  required String gameId,
  required Difficulty difficulty,
}) => XfutebolBridge.instance.api.crateApiGetBotAction(
  gameId: gameId,
  difficulty: difficulty,
);

/// Check if the game is over
Future<bool> isGameOver({required String gameId}) =>
    XfutebolBridge.instance.api.crateApiIsGameOver(gameId: gameId);

/// Get the winner (if game is over)
Future<Team?> getWinner({required String gameId}) =>
    XfutebolBridge.instance.api.crateApiGetWinner(gameId: gameId);

/// Check if a game exists
Future<bool> gameExists({required String gameId}) =>
    XfutebolBridge.instance.api.crateApiGameExists(gameId: gameId);

/// Delete a game session and free memory
Future<bool> deleteGame({required String gameId}) =>
    XfutebolBridge.instance.api.crateApiDeleteGame(gameId: gameId);

/// Get the current match state summary
Future<MatchStateView?> getMatchState({required String gameId}) =>
    XfutebolBridge.instance.api.crateApiGetMatchState(gameId: gameId);

/// Get the complete action log for a game
Future<List<ActionLogView>> getActionLog({required String gameId}) =>
    XfutebolBridge.instance.api.crateApiGetActionLog(gameId: gameId);

/// Get the last N actions from a game (for recent activity display)
Future<List<ActionLogView>> getLastNActions({
  required String gameId,
  required int n,
}) => XfutebolBridge.instance.api.crateApiGetLastNActions(gameId: gameId, n: n);

/// Export the current board state as notation string (for debugging)
Future<String?> exportBoardNotation({required String gameId}) =>
    XfutebolBridge.instance.api.crateApiExportBoardNotation(gameId: gameId);

/// Simple test function to verify bridge works
Future<String> greet({required String name}) =>
    XfutebolBridge.instance.api.crateApiGreet(name: name);

/// A single recorded action from the game log
class ActionLogView {
  final String? pieceId;
  final Team? team;
  final ActionType actionType;
  final Position from;
  final Position to;
  final List<Position> path;
  final BigInt timestampMs;

  const ActionLogView({
    this.pieceId,
    this.team,
    required this.actionType,
    required this.from,
    required this.to,
    required this.path,
    required this.timestampMs,
  });

  @override
  int get hashCode =>
      pieceId.hashCode ^
      team.hashCode ^
      actionType.hashCode ^
      from.hashCode ^
      to.hashCode ^
      path.hashCode ^
      timestampMs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ActionLogView &&
          runtimeType == other.runtimeType &&
          pieceId == other.pieceId &&
          team == other.team &&
          actionType == other.actionType &&
          from == other.from &&
          to == other.to &&
          path == other.path &&
          timestampMs == other.timestampMs;
}

/// Result of an action
class ActionResult {
  final bool success;
  final String message;
  final bool gameOver;
  final Team? winner;
  final int actionsRemaining;

  /// Which team scored a goal (if any) - None means no goal
  final Team? goalScored;

  /// Whether the turn ended after this action
  final bool turnEnded;

  /// Whether ball was reset to center after a goal (kickoff)
  final bool kickoffReset;

  const ActionResult({
    required this.success,
    required this.message,
    required this.gameOver,
    this.winner,
    required this.actionsRemaining,
    this.goalScored,
    required this.turnEnded,
    required this.kickoffReset,
  });

  @override
  int get hashCode =>
      success.hashCode ^
      message.hashCode ^
      gameOver.hashCode ^
      winner.hashCode ^
      actionsRemaining.hashCode ^
      goalScored.hashCode ^
      turnEnded.hashCode ^
      kickoffReset.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ActionResult &&
          runtimeType == other.runtimeType &&
          success == other.success &&
          message == other.message &&
          gameOver == other.gameOver &&
          winner == other.winner &&
          actionsRemaining == other.actionsRemaining &&
          goalScored == other.goalScored &&
          turnEnded == other.turnEnded &&
          kickoffReset == other.kickoffReset;
}

/// Action types available in the game
enum ActionType { move, pass, shoot, intercept, kick, defend, push }

/// Current state of the board for display
class BoardView {
  final List<PieceView> pieces;
  final Position? ballPosition;
  final Team currentTurn;
  final int actionsRemaining;
  final int whiteScore;
  final int blackScore;
  final int turnNumber;

  const BoardView({
    required this.pieces,
    this.ballPosition,
    required this.currentTurn,
    required this.actionsRemaining,
    required this.whiteScore,
    required this.blackScore,
    required this.turnNumber,
  });

  @override
  int get hashCode =>
      pieces.hashCode ^
      ballPosition.hashCode ^
      currentTurn.hashCode ^
      actionsRemaining.hashCode ^
      whiteScore.hashCode ^
      blackScore.hashCode ^
      turnNumber.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BoardView &&
          runtimeType == other.runtimeType &&
          pieces == other.pieces &&
          ballPosition == other.ballPosition &&
          currentTurn == other.currentTurn &&
          actionsRemaining == other.actionsRemaining &&
          whiteScore == other.whiteScore &&
          blackScore == other.blackScore &&
          turnNumber == other.turnNumber;
}

/// A complete action returned by the bot AI
class BotAction {
  final String pieceId;
  final ActionType actionType;
  final List<Position> path;

  const BotAction({
    required this.pieceId,
    required this.actionType,
    required this.path,
  });

  @override
  int get hashCode => pieceId.hashCode ^ actionType.hashCode ^ path.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BotAction &&
          runtimeType == other.runtimeType &&
          pieceId == other.pieceId &&
          actionType == other.actionType &&
          path == other.path;
}

/// Game difficulty levels
enum Difficulty { easy, medium }

/// Game mode options
enum GameModeType { quickMatch, standardMatch, goldenGoal }

/// Match state summary with action log
class MatchStateView {
  final String gameId;
  final GameModeType mode;
  final int currentTurn;
  final int actionsRemaining;
  final int scoreWhite;
  final int scoreBlack;
  final bool isFinished;
  final Team? winner;
  final int actionCount;
  final String boardNotation;

  const MatchStateView({
    required this.gameId,
    required this.mode,
    required this.currentTurn,
    required this.actionsRemaining,
    required this.scoreWhite,
    required this.scoreBlack,
    required this.isFinished,
    this.winner,
    required this.actionCount,
    required this.boardNotation,
  });

  @override
  int get hashCode =>
      gameId.hashCode ^
      mode.hashCode ^
      currentTurn.hashCode ^
      actionsRemaining.hashCode ^
      scoreWhite.hashCode ^
      scoreBlack.hashCode ^
      isFinished.hashCode ^
      winner.hashCode ^
      actionCount.hashCode ^
      boardNotation.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MatchStateView &&
          runtimeType == other.runtimeType &&
          gameId == other.gameId &&
          mode == other.mode &&
          currentTurn == other.currentTurn &&
          actionsRemaining == other.actionsRemaining &&
          scoreWhite == other.scoreWhite &&
          scoreBlack == other.scoreBlack &&
          isFinished == other.isFinished &&
          winner == other.winner &&
          actionCount == other.actionCount &&
          boardNotation == other.boardNotation;
}

/// Piece roles
enum PieceRole { goalkeeper, defender, midfielder, attacker }

/// A piece on the board
class PieceView {
  final String id;
  final Team team;
  final PieceRole role;
  final Position position;
  final bool hasBall;

  const PieceView({
    required this.id,
    required this.team,
    required this.role,
    required this.position,
    required this.hasBall,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      team.hashCode ^
      role.hashCode ^
      position.hashCode ^
      hasBall.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PieceView &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          team == other.team &&
          role == other.role &&
          position == other.position &&
          hasBall == other.hasBall;
}

/// A position on the board (0-7 for row and col)
class Position {
  final int row;
  final int col;

  const Position({required this.row, required this.col});

  @override
  int get hashCode => row.hashCode ^ col.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Position &&
          runtimeType == other.runtimeType &&
          row == other.row &&
          col == other.col;
}

/// A path of positions (wrapper to avoid nested Vec issues in codegen)
class PositionPath {
  final List<Position> positions;

  const PositionPath({required this.positions});

  @override
  int get hashCode => positions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PositionPath &&
          runtimeType == other.runtimeType &&
          positions == other.positions;
}

/// Team colors
enum Team { white, black }
