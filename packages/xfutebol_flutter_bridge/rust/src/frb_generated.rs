// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.11.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 1234028629;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__execute_move_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    game_id: impl CstDecode<String>,
    piece_id: impl CstDecode<u8>,
    to: impl CstDecode<crate::api::Position>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "execute_move",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_game_id = game_id.cst_decode();
            let api_piece_id = piece_id.cst_decode();
            let api_to = to.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::execute_move(
                        api_game_id,
                        api_piece_id,
                        api_to,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__get_board_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    game_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_board",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_game_id = game_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::get_board(api_game_id))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__get_bot_move_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    game_id: impl CstDecode<String>,
    difficulty: impl CstDecode<crate::api::Difficulty>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_bot_move",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_game_id = game_id.cst_decode();
            let api_difficulty = difficulty.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::get_bot_move(api_game_id, api_difficulty))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__get_legal_moves_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    game_id: impl CstDecode<String>,
    piece_id: impl CstDecode<u8>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_legal_moves",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_game_id = game_id.cst_decode();
            let api_piece_id = piece_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::get_legal_moves(
                        api_game_id,
                        api_piece_id,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__get_winner_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    game_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_winner",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_game_id = game_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::get_winner(api_game_id))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__greet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    name: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "greet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_name = name.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::greet(api_name))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__is_game_over_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    game_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_game_over",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_game_id = game_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::is_game_over(api_game_id))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__new_game_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mode: impl CstDecode<crate::api::GameModeType>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "new_game",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mode = mode.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::new_game(api_mode))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<crate::api::Difficulty> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::Difficulty {
        match self {
            0 => crate::api::Difficulty::Easy,
            1 => crate::api::Difficulty::Medium,
            2 => crate::api::Difficulty::Hard,
            _ => unreachable!("Invalid variant for Difficulty: {}", self),
        }
    }
}
impl CstDecode<crate::api::GameModeType> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::GameModeType {
        match self {
            0 => crate::api::GameModeType::QuickMatch,
            1 => crate::api::GameModeType::StandardMatch,
            2 => crate::api::GameModeType::GoldenGoal,
            _ => unreachable!("Invalid variant for GameModeType: {}", self),
        }
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<crate::api::PieceRole> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::PieceRole {
        match self {
            0 => crate::api::PieceRole::Goalkeeper,
            1 => crate::api::PieceRole::Defender,
            2 => crate::api::PieceRole::Midfielder,
            3 => crate::api::PieceRole::Attacker,
            _ => unreachable!("Invalid variant for PieceRole: {}", self),
        }
    }
}
impl CstDecode<crate::api::Team> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::Team {
        match self {
            0 => crate::api::Team::White,
            1 => crate::api::Team::Black,
            _ => unreachable!("Invalid variant for Team: {}", self),
        }
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::ActionResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_message = <String>::sse_decode(deserializer);
        let mut var_gameOver = <bool>::sse_decode(deserializer);
        let mut var_winner = <Option<crate::api::Team>>::sse_decode(deserializer);
        return crate::api::ActionResult {
            success: var_success,
            message: var_message,
            game_over: var_gameOver,
            winner: var_winner,
        };
    }
}

impl SseDecode for crate::api::BoardView {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_pieces = <Vec<crate::api::PieceView>>::sse_decode(deserializer);
        let mut var_ballPosition = <Option<crate::api::Position>>::sse_decode(deserializer);
        let mut var_currentTurn = <crate::api::Team>::sse_decode(deserializer);
        let mut var_actionsRemaining = <u8>::sse_decode(deserializer);
        let mut var_whiteScore = <u8>::sse_decode(deserializer);
        let mut var_blackScore = <u8>::sse_decode(deserializer);
        let mut var_turnNumber = <u32>::sse_decode(deserializer);
        return crate::api::BoardView {
            pieces: var_pieces,
            ball_position: var_ballPosition,
            current_turn: var_currentTurn,
            actions_remaining: var_actionsRemaining,
            white_score: var_whiteScore,
            black_score: var_blackScore,
            turn_number: var_turnNumber,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::Difficulty {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::Difficulty::Easy,
            1 => crate::api::Difficulty::Medium,
            2 => crate::api::Difficulty::Hard,
            _ => unreachable!("Invalid variant for Difficulty: {}", inner),
        };
    }
}

impl SseDecode for crate::api::GameModeType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::GameModeType::QuickMatch,
            1 => crate::api::GameModeType::StandardMatch,
            2 => crate::api::GameModeType::GoldenGoal,
            _ => unreachable!("Invalid variant for GameModeType: {}", inner),
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for Vec<crate::api::PieceView> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::PieceView>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::Position> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::Position>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Option<crate::api::Position> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::Position>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<(u8, crate::api::Position)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<(u8, crate::api::Position)>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::Team> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::Team>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::PieceRole {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::PieceRole::Goalkeeper,
            1 => crate::api::PieceRole::Defender,
            2 => crate::api::PieceRole::Midfielder,
            3 => crate::api::PieceRole::Attacker,
            _ => unreachable!("Invalid variant for PieceRole: {}", inner),
        };
    }
}

impl SseDecode for crate::api::PieceView {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <u8>::sse_decode(deserializer);
        let mut var_team = <crate::api::Team>::sse_decode(deserializer);
        let mut var_role = <crate::api::PieceRole>::sse_decode(deserializer);
        let mut var_position = <crate::api::Position>::sse_decode(deserializer);
        let mut var_hasBall = <bool>::sse_decode(deserializer);
        return crate::api::PieceView {
            id: var_id,
            team: var_team,
            role: var_role,
            position: var_position,
            has_ball: var_hasBall,
        };
    }
}

impl SseDecode for crate::api::Position {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_row = <u8>::sse_decode(deserializer);
        let mut var_col = <u8>::sse_decode(deserializer);
        return crate::api::Position {
            row: var_row,
            col: var_col,
        };
    }
}

impl SseDecode for (u8, crate::api::Position) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <u8>::sse_decode(deserializer);
        let mut var_field1 = <crate::api::Position>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::api::Team {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::Team::White,
            1 => crate::api::Team::Black,
            _ => unreachable!("Invalid variant for Team: {}", inner),
        };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::ActionResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.message.into_into_dart().into_dart(),
            self.game_over.into_into_dart().into_dart(),
            self.winner.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::ActionResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::ActionResult> for crate::api::ActionResult {
    fn into_into_dart(self) -> crate::api::ActionResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::BoardView {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.pieces.into_into_dart().into_dart(),
            self.ball_position.into_into_dart().into_dart(),
            self.current_turn.into_into_dart().into_dart(),
            self.actions_remaining.into_into_dart().into_dart(),
            self.white_score.into_into_dart().into_dart(),
            self.black_score.into_into_dart().into_dart(),
            self.turn_number.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::BoardView {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::BoardView> for crate::api::BoardView {
    fn into_into_dart(self) -> crate::api::BoardView {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::Difficulty {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Easy => 0.into_dart(),
            Self::Medium => 1.into_dart(),
            Self::Hard => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::Difficulty {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::Difficulty> for crate::api::Difficulty {
    fn into_into_dart(self) -> crate::api::Difficulty {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::GameModeType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::QuickMatch => 0.into_dart(),
            Self::StandardMatch => 1.into_dart(),
            Self::GoldenGoal => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::GameModeType {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::GameModeType> for crate::api::GameModeType {
    fn into_into_dart(self) -> crate::api::GameModeType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::PieceRole {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Goalkeeper => 0.into_dart(),
            Self::Defender => 1.into_dart(),
            Self::Midfielder => 2.into_dart(),
            Self::Attacker => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::PieceRole {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::PieceRole> for crate::api::PieceRole {
    fn into_into_dart(self) -> crate::api::PieceRole {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::PieceView {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.team.into_into_dart().into_dart(),
            self.role.into_into_dart().into_dart(),
            self.position.into_into_dart().into_dart(),
            self.has_ball.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::PieceView {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::PieceView> for crate::api::PieceView {
    fn into_into_dart(self) -> crate::api::PieceView {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::Position {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.row.into_into_dart().into_dart(),
            self.col.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::Position {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::Position> for crate::api::Position {
    fn into_into_dart(self) -> crate::api::Position {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::Team {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::White => 0.into_dart(),
            Self::Black => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::Team {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::Team> for crate::api::Team {
    fn into_into_dart(self) -> crate::api::Team {
        self
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::ActionResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <String>::sse_encode(self.message, serializer);
        <bool>::sse_encode(self.game_over, serializer);
        <Option<crate::api::Team>>::sse_encode(self.winner, serializer);
    }
}

impl SseEncode for crate::api::BoardView {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::api::PieceView>>::sse_encode(self.pieces, serializer);
        <Option<crate::api::Position>>::sse_encode(self.ball_position, serializer);
        <crate::api::Team>::sse_encode(self.current_turn, serializer);
        <u8>::sse_encode(self.actions_remaining, serializer);
        <u8>::sse_encode(self.white_score, serializer);
        <u8>::sse_encode(self.black_score, serializer);
        <u32>::sse_encode(self.turn_number, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::Difficulty {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::Difficulty::Easy => 0,
                crate::api::Difficulty::Medium => 1,
                crate::api::Difficulty::Hard => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::GameModeType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::GameModeType::QuickMatch => 0,
                crate::api::GameModeType::StandardMatch => 1,
                crate::api::GameModeType::GoldenGoal => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for Vec<crate::api::PieceView> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::PieceView>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::Position> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::Position>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::Position> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::Position>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<(u8, crate::api::Position)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <(u8, crate::api::Position)>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::Team> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::Team>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::PieceRole {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::PieceRole::Goalkeeper => 0,
                crate::api::PieceRole::Defender => 1,
                crate::api::PieceRole::Midfielder => 2,
                crate::api::PieceRole::Attacker => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::PieceView {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u8>::sse_encode(self.id, serializer);
        <crate::api::Team>::sse_encode(self.team, serializer);
        <crate::api::PieceRole>::sse_encode(self.role, serializer);
        <crate::api::Position>::sse_encode(self.position, serializer);
        <bool>::sse_encode(self.has_ball, serializer);
    }
}

impl SseEncode for crate::api::Position {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u8>::sse_encode(self.row, serializer);
        <u8>::sse_encode(self.col, serializer);
    }
}

impl SseEncode for (u8, crate::api::Position) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u8>::sse_encode(self.0, serializer);
        <crate::api::Position>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::api::Team {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::Team::White => 0,
                crate::api::Team::Black => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    // Section: dart2rust

    impl CstDecode<String> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            let vec: Vec<u8> = self.cst_decode();
            String::from_utf8(vec).unwrap()
        }
    }
    impl CstDecode<crate::api::ActionResult> for wire_cst_action_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::ActionResult {
            crate::api::ActionResult {
                success: self.success.cst_decode(),
                message: self.message.cst_decode(),
                game_over: self.game_over.cst_decode(),
                winner: self.winner.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::BoardView> for wire_cst_board_view {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::BoardView {
            crate::api::BoardView {
                pieces: self.pieces.cst_decode(),
                ball_position: self.ball_position.cst_decode(),
                current_turn: self.current_turn.cst_decode(),
                actions_remaining: self.actions_remaining.cst_decode(),
                white_score: self.white_score.cst_decode(),
                black_score: self.black_score.cst_decode(),
                turn_number: self.turn_number.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::Position> for *mut wire_cst_position {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::Position {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::Position>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<(u8, crate::api::Position)> for *mut wire_cst_record_u_8_position {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (u8, crate::api::Position) {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<(u8, crate::api::Position)>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::Team> for *mut i32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::Team {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::Team>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<Vec<crate::api::PieceView>> for *mut wire_cst_list_piece_view {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::PieceView> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::Position>> for *mut wire_cst_list_position {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::Position> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<crate::api::PieceView> for wire_cst_piece_view {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::PieceView {
            crate::api::PieceView {
                id: self.id.cst_decode(),
                team: self.team.cst_decode(),
                role: self.role.cst_decode(),
                position: self.position.cst_decode(),
                has_ball: self.has_ball.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::Position> for wire_cst_position {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::Position {
            crate::api::Position {
                row: self.row.cst_decode(),
                col: self.col.cst_decode(),
            }
        }
    }
    impl CstDecode<(u8, crate::api::Position)> for wire_cst_record_u_8_position {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (u8, crate::api::Position) {
            (self.field0.cst_decode(), self.field1.cst_decode())
        }
    }
    impl NewWithNullPtr for wire_cst_action_result {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                message: core::ptr::null_mut(),
                game_over: Default::default(),
                winner: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_action_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_board_view {
        fn new_with_null_ptr() -> Self {
            Self {
                pieces: core::ptr::null_mut(),
                ball_position: core::ptr::null_mut(),
                current_turn: Default::default(),
                actions_remaining: Default::default(),
                white_score: Default::default(),
                black_score: Default::default(),
                turn_number: Default::default(),
            }
        }
    }
    impl Default for wire_cst_board_view {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_piece_view {
        fn new_with_null_ptr() -> Self {
            Self {
                id: Default::default(),
                team: Default::default(),
                role: Default::default(),
                position: Default::default(),
                has_ball: Default::default(),
            }
        }
    }
    impl Default for wire_cst_piece_view {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_position {
        fn new_with_null_ptr() -> Self {
            Self {
                row: Default::default(),
                col: Default::default(),
            }
        }
    }
    impl Default for wire_cst_position {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_u_8_position {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: Default::default(),
                field1: Default::default(),
            }
        }
    }
    impl Default for wire_cst_record_u_8_position {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_xfutebol_flutter_bridge_wire__crate__api__execute_move(
        port_: i64,
        game_id: *mut wire_cst_list_prim_u_8_strict,
        piece_id: u8,
        to: *mut wire_cst_position,
    ) {
        wire__crate__api__execute_move_impl(port_, game_id, piece_id, to)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_xfutebol_flutter_bridge_wire__crate__api__get_board(
        port_: i64,
        game_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__get_board_impl(port_, game_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_xfutebol_flutter_bridge_wire__crate__api__get_bot_move(
        port_: i64,
        game_id: *mut wire_cst_list_prim_u_8_strict,
        difficulty: i32,
    ) {
        wire__crate__api__get_bot_move_impl(port_, game_id, difficulty)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_xfutebol_flutter_bridge_wire__crate__api__get_legal_moves(
        port_: i64,
        game_id: *mut wire_cst_list_prim_u_8_strict,
        piece_id: u8,
    ) {
        wire__crate__api__get_legal_moves_impl(port_, game_id, piece_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_xfutebol_flutter_bridge_wire__crate__api__get_winner(
        port_: i64,
        game_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__get_winner_impl(port_, game_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_xfutebol_flutter_bridge_wire__crate__api__greet(
        port_: i64,
        name: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__greet_impl(port_, name)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_xfutebol_flutter_bridge_wire__crate__api__is_game_over(
        port_: i64,
        game_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__is_game_over_impl(port_, game_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_xfutebol_flutter_bridge_wire__crate__api__new_game(
        port_: i64,
        mode: i32,
    ) {
        wire__crate__api__new_game_impl(port_, mode)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_xfutebol_flutter_bridge_cst_new_box_autoadd_position(
    ) -> *mut wire_cst_position {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_position::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_xfutebol_flutter_bridge_cst_new_box_autoadd_record_u_8_position(
    ) -> *mut wire_cst_record_u_8_position {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_record_u_8_position::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_xfutebol_flutter_bridge_cst_new_box_autoadd_team(
        value: i32,
    ) -> *mut i32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_xfutebol_flutter_bridge_cst_new_list_piece_view(
        len: i32,
    ) -> *mut wire_cst_list_piece_view {
        let wrap = wire_cst_list_piece_view {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_piece_view>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_xfutebol_flutter_bridge_cst_new_list_position(
        len: i32,
    ) -> *mut wire_cst_list_position {
        let wrap = wire_cst_list_position {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_position>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_xfutebol_flutter_bridge_cst_new_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_strict {
        let ans = wire_cst_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_action_result {
        success: bool,
        message: *mut wire_cst_list_prim_u_8_strict,
        game_over: bool,
        winner: *mut i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_board_view {
        pieces: *mut wire_cst_list_piece_view,
        ball_position: *mut wire_cst_position,
        current_turn: i32,
        actions_remaining: u8,
        white_score: u8,
        black_score: u8,
        turn_number: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_piece_view {
        ptr: *mut wire_cst_piece_view,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_position {
        ptr: *mut wire_cst_position,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_strict {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_piece_view {
        id: u8,
        team: i32,
        role: i32,
        position: wire_cst_position,
        has_ball: bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_position {
        row: u8,
        col: u8,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_u_8_position {
        field0: u8,
        field1: wire_cst_position,
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();

    // Section: dart2rust

    impl CstDecode<String> for String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            self
        }
    }
    impl CstDecode<crate::api::ActionResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::ActionResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::api::ActionResult {
                success: self_.get(0).cst_decode(),
                message: self_.get(1).cst_decode(),
                game_over: self_.get(2).cst_decode(),
                winner: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::BoardView>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::BoardView {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                7,
                "Expected 7 elements, got {}",
                self_.length()
            );
            crate::api::BoardView {
                pieces: self_.get(0).cst_decode(),
                ball_position: self_.get(1).cst_decode(),
                current_turn: self_.get(2).cst_decode(),
                actions_remaining: self_.get(3).cst_decode(),
                white_score: self_.get(4).cst_decode(),
                black_score: self_.get(5).cst_decode(),
                turn_number: self_.get(6).cst_decode(),
            }
        }
    }
    impl CstDecode<Vec<crate::api::PieceView>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::PieceView> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::api::Position>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::Position> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<u8>> for Box<[u8]> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            self.into_vec()
        }
    }
    impl CstDecode<crate::api::PieceView>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::PieceView {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                5,
                "Expected 5 elements, got {}",
                self_.length()
            );
            crate::api::PieceView {
                id: self_.get(0).cst_decode(),
                team: self_.get(1).cst_decode(),
                role: self_.get(2).cst_decode(),
                position: self_.get(3).cst_decode(),
                has_ball: self_.get(4).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::Position> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::Position {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            crate::api::Position {
                row: self_.get(0).cst_decode(),
                col: self_.get(1).cst_decode(),
            }
        }
    }
    impl CstDecode<(u8, crate::api::Position)>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (u8, crate::api::Position) {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            (self_.get(0).cst_decode(), self_.get(1).cst_decode())
        }
    }
    impl CstDecode<String> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            self.as_string().expect("non-UTF-8 string, or not a string")
        }
    }
    impl CstDecode<bool> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> bool {
            self.is_truthy()
        }
    }
    impl CstDecode<crate::api::Difficulty>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::Difficulty {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<crate::api::GameModeType>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::GameModeType {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<i32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> i32 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<Vec<u8>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Uint8Array>()
                .to_vec()
                .into()
        }
    }
    impl CstDecode<crate::api::PieceRole>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::PieceRole {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<crate::api::Team> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::Team {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<u32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<u8> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u8 {
            self.unchecked_into_f64() as _
        }
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__execute_move(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        game_id: String,
        piece_id: u8,
        to: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__execute_move_impl(port_, game_id, piece_id, to)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_board(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        game_id: String,
    ) {
        wire__crate__api__get_board_impl(port_, game_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_bot_move(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        game_id: String,
        difficulty: i32,
    ) {
        wire__crate__api__get_bot_move_impl(port_, game_id, difficulty)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_legal_moves(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        game_id: String,
        piece_id: u8,
    ) {
        wire__crate__api__get_legal_moves_impl(port_, game_id, piece_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_winner(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        game_id: String,
    ) {
        wire__crate__api__get_winner_impl(port_, game_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__greet(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        name: String,
    ) {
        wire__crate__api__greet_impl(port_, name)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__is_game_over(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        game_id: String,
    ) {
        wire__crate__api__is_game_over_impl(port_, game_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__new_game(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        mode: i32,
    ) {
        wire__crate__api__new_game_impl(port_, mode)
    }
}
#[cfg(target_family = "wasm")]
pub use web::*;
